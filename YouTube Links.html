<html>
<title>Alan Noah Jose</title>
<h1>Alan Noah Jose's YouTube links</h1>
<style>
h1{color:blue}
h2{color:red}
p{color:cyan}
</style>
<style>
body {
  background-image: url('https://images.hdqwalls.com/download/sky-full-of-stars-space-5k-h0-2880x1800.jpg');
}
</style>
<head>
<canvas></canvas>


<div class="links">
    <a href="https://dev.to/uuuuuulala/coding-an-interactive-and-damn-satisfying-cursor-7-simple-steps-2kb-of-code-1c8b" target="_blank">tutorial<img class="icon" src="https://ksenia-k.com/img/icons/link.svg"></a>
</div>

  <style>
   body, html {
    padding: 0;
    margin: 0;
	 overscroll-behavior: none;
	 overflow: hidden;
}

/* for tutorial link only */
.links {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 18px;
    font-family: sans-serif;
	 background-color: white;
	 padding: 10px;
}
a {
    text-decoration: none;
    color: black;
    margin-left: 1em;
}
a:hover {
    text-decoration: underline;
}
a img.icon {
    display: inline-block;
    height: 1em;
    margin: 0 0 -0.1em 0.3em;
}
  </style>
  <script>
    const canvas = document.querySelector("canvas");
const ctx = canvas.getContext('2d');

// for intro motion
let mouseMoved = false;

const pointer = {
    x: .5 * window.innerWidth,
    y: .5 * window.innerHeight,
}
const params = {
    pointsNumber: 40,
    widthFactor: .3,
    mouseThreshold: .6,
    spring: .4,
    friction: .5
};

const trail = new Array(params.pointsNumber);
for (let i = 0; i < params.pointsNumber; i++) {
    trail[i] = {
        x: pointer.x,
        y: pointer.y,
        dx: 0,
        dy: 0,
    }
}

window.addEventListener("click", e => {
    updateMousePosition(e.pageX, e.pageY);
});
window.addEventListener("mousemove", e => {
    mouseMoved = true;
    updateMousePosition(e.pageX, e.pageY);
});
window.addEventListener("touchmove", e => {
    mouseMoved = true;
    updateMousePosition(e.targetTouches[0].pageX, e.targetTouches[0].pageY);
});

function updateMousePosition(eX, eY) {
    pointer.x = eX;
    pointer.y = eY;
}

setupCanvas();
update(0);
window.addEventListener("resize", setupCanvas);


function update(t) {

    // for intro motion
    if (!mouseMoved) {
        pointer.x = (.5 + .3 * Math.cos(.002 * t) * (Math.sin(.005 * t))) * window.innerWidth;
        pointer.y = (.5 + .2 * (Math.cos(.005 * t)) + .1 * Math.cos(.01 * t)) * window.innerHeight;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    trail.forEach((p, pIdx) => {
        const prev = pIdx === 0 ? pointer : trail[pIdx - 1];
        const spring = pIdx === 0 ? .4 * params.spring : params.spring;
        p.dx += (prev.x - p.x) * spring;
        p.dy += (prev.y - p.y) * spring;
        p.dx *= params.friction;
        p.dy *= params.friction;
        p.x += p.dx;
        p.y += p.dy;
    });

    ctx.lineCap = "round";
	 ctx.beginPath();
    ctx.moveTo(trail[0].x, trail[0].y);

    for (let i = 1; i < trail.length - 1; i++) {
        const xc = .5 * (trail[i].x + trail[i + 1].x);
        const yc = .5 * (trail[i].y + trail[i + 1].y);
        ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
        ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);
        ctx.stroke();
    }
    ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
    ctx.stroke();
    
    window.requestAnimationFrame(update);
}

function setupCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
  </script>
</head>
<head>
<button class="toggleRays" id="toggleRays">Toggle rays</button>
  <style>
   html, body { margin: 0; width: 100%, height: 100% }
canvas {display: block;}

.toggleRays { position: fixed; }
  </style>
  <script>
   const rayCount = 420;
const rayLength = 250;
const shadowOpacity = 0.8;

const textures = {
  crewmate: 'https://i.imgur.com/NaEDTu0.png',
  ghost: 'https://i.imgur.com/R1kxL21.png',
  body: 'https://i.imgur.com/9je6Kqh.png',
  body2: 'https://i.imgur.com/15aU3ZI.png',
}

const renderer = new PIXI.Renderer({
  width: window.innerWidth || 500,
  height: window.innerHeight || 500,
  autoDensity: true,
  resolution: window.devicePixelRatio,
});

class Vector2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

function magnitude(v1, v2) {
  const a = v1.x - v2.x;
  const b = v1.y - v2.y;
  return a * a + b * b;
}

class Boundary {
  constructor(x1, y1, x2, y2) {
    this.a = new Vector2(x1, y1);
    this.b = new Vector2(x2, y2);
  }
  
  draw() {
    const g = new PIXI.Graphics();
    g.beginFill(0xFFAAAA, 1);
    g.lineStyle(1, 0x00FF00);
    g.moveTo(this.a.x, this.a.y);
    g.lineTo(this.b.x, this.b.y);
    g.endFill();
    return g;
  }
}

class Ray {
  constructor(x, y, angle, length) {
    const radians = angle * (Math.PI / 180);
    this.pos = new Vector2(x, y);
    this.dir = new Vector2(Math.cos(radians) * length, Math.sin(radians) * length);
    this.end = new Vector2((x + this.dir.x), (y + this.dir.y));
  }
  
  setPosition(x, y) {
    this.pos.x = x;
    this.pos.y = y;
    this.end.x = (this.pos.x + this.dir.x);
    this.end.y = (this.pos.y + this.dir.y);
  }
  
  draw(g = new PIXI.Graphics()) {
    g.beginFill(0x00FF00, 1);
    g.lineStyle(1, 0xFFFFFF);
    g.moveTo(this.pos.x, this.pos.y);
    g.lineTo(this.end.x, this.end.y);
    return g;
  }
  
  cast(wall) {
    const x1 = wall.a.x;
    const y1 = wall.a.y;
    const x2 = wall.b.x;
    const y2 = wall.b.y;

    const x3 = this.pos.x;
    const y3 = this.pos.y;
    const x4 = this.pos.x + this.dir.x;
    const y4 = this.pos.y + this.dir.y;

    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (den == 0) {
      return;
    }

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
    if (t > 0 && t < 1 && u > 0) {
      const pt = new Vector2();
      pt.x = x1 + t * (x2 - x1);
      pt.y = y1 + t * (y2 - y1);
      return pt;
    } else {
      return;
    }
  }
}

const boundaries = [
  // office
  // top
  new Boundary(190, 150, 300, 150),
  new Boundary(570, 150, 1045, 150),
  // vertical
  new Boundary(190, 150, 190, 440),
  new Boundary(695, 150, 695, 320),
  new Boundary(1045, 150, 1045, 200),
  new Boundary(1045, 300, 1045, 320),
  // bottom
  new Boundary(190, 320, 240, 320),
  new Boundary(325, 320, 570, 320),
  new Boundary(660, 320, 715, 320),
  new Boundary(800, 320, 1045, 320),
  // corridor / admin
  // top
  new Boundary(190, 440, 330, 440),
  new Boundary(415, 440, 485, 440),
  new Boundary(580, 440, 830, 440),
  // Vertical
  new Boundary(295, 440, 295, 500),
  new Boundary(295, 610, 295, 640),
  new Boundary(442, 440, 442, 700),
  new Boundary(595, 440, 595, 550),
  new Boundary(830, 320, 830, 650),
  // Bottom
  new Boundary(295, 640, 442, 640),
  new Boundary(640, 650, 830, 650),
  new Boundary(640, 650, 640, 700),
  // Right corridor  
  new Boundary(950, 420, 1220, 420),
  new Boundary(1070, 530, 1220, 530),
  new Boundary(950, 420, 925, 450),
  new Boundary(925, 450, 925, 700),
  new Boundary(950, 420, 1220, 420),
  new Boundary(1070, 530, 1040, 560),
  new Boundary(1040, 560, 1040, 700),
];

// Prepare rays
const raySpace = 360 / rayCount;
const rays = [];
const lightmapPoly = [];

for (let i = 0; i < rayCount; i += 1) {
  rays.push(new Ray(0, 0, i * raySpace, rayLength));
  lightmapPoly.push(new PIXI.Point(0, 0));
}

// Prepare stages
const stage = new PIXI.Container();
const debugStage = new PIXI.Container();
debugStage.visible = false;

// map background
const background = PIXI.Sprite.from('https://i.imgur.com/aCEVtrK.png');
background.scale.set(0.5, 0.5)
stage.addChild(background);

// Rays vizualisation
const rayGraphics = new PIXI.Graphics();
rayGraphics.alpha = 0.5;
debugStage.addChild(rayGraphics);

// Show these walls
boundaries.map(boundary => debugStage.addChild(boundary.draw()));
document.body.appendChild(renderer.view);

// Easy crewmates
const createCrewmate = (x, y, tex, name) => {
  const body = new PIXI.Sprite.from(textures[tex]);
  body.position.set(x, y);
  body.anchor.set(0.5);
  body.scale.set(0.4);
  body.visible = false;
  if (name) {
    const text = new PIXI.Text(name, { fill: 'white', strokeThickness: 4 });
    text.anchor.set(0.5);
    text.position.set(0, 70);
    body.addChild(text);
  }
  stage.addChild(body)
  return body;
};

const crewmates = [
  createCrewmate(220, 60, 'body'),
  createCrewmate(230, 600, 'crewmate', 'U idiots I'),
  createCrewmate(800, 240, 'crewmate', 'FRADAR'),
  createCrewmate(840, 240, 'body2', 'Red'),
  createCrewmate(630, 540, 'body'),
  createCrewmate(990, 480, 'crewmate', 'Vented'),
];

const lightmap = new PIXI.Graphics();

// Nice blur effect, but sharp edges makes demo clearer
// lightmap.filters = [new PIXI.filters.BlurFilter(16)];
stage.addChild(lightmap);
stage.addChild(debugStage);

// Crewmate following mouse
const crewmate = createCrewmate(-100, -100, 'ghost', 'Crewmate');
crewmate.visible = true;

stage.interactive = true;
stage.on('mousemove', event => {
  const { x, y } = event.data.global;
  
  crewmate.position.set(x, y);
  // Fill lightmap with big shadow
  lightmap.clear();
  lightmap.beginFill(0x000000, shadowOpacity);
  lightmap.drawRect(0, 0, renderer.width, renderer.height);
  lightmap.beginHole();
  
  rayGraphics.clear();
  for (let i = 0; i < rays.length; i += 1) {
    const ray = rays[i];

    // move ray
    ray.setPosition(x | 0, y | 0);
    
    for (let j = 0; j < boundaries.length; j += 1) {
      // raycasting
      const hit = ray.cast(boundaries[j]);

      // Set ray end if hit is nearer than current end
      if (hit) {
        const len = magnitude(ray.pos, ray.end);
        const hitLen = magnitude(ray.pos, hit);
        if (hitLen < len) {
          ray.end = hit;
        }
      }
      // draw hole in lightmap shadows
      lightmapPoly[i].set(Math.min(Math.max(ray.end.x, 0), window.innerWidth), Math.min(Math.max(ray.end.y, 0), window.innerHeight));
    }
    ray.draw(rayGraphics);
  }
  
  lightmap.drawPolygon(lightmapPoly);
  lightmap.endHole();
  lightmap.endFill();
  
  // Test bodies for visibility
  const poly = new PIXI.Polygon(lightmapPoly);
  for (let i = 0; i < crewmates.length; i += 1) {
    const body = crewmates[i];
    body.visible = poly.contains(body.x, body.y);
  }
})

function render() {
  renderer.render(stage);
  requestAnimationFrame(render);
}

render();

const resize = () => renderer.resize(window.innerWidth, window.innerHeight);
window.addEventListener('resize', resize);
setTimeout(resize, 1);

document.getElementById('toggleRays').addEventListener('click', function toggleRays() {
  console.log('toggle rays')
  debugStage.visible = !debugStage.visible;
})
  </script>
</head>
</html>
  
